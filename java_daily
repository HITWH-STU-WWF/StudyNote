对象作为程序的基本单位，将程序和数据封装其中，以提高程序的重用性，灵活性和可扩展性。类是创建对象的模板，一个类可以创建多个对象。对象是类的实例化。
类是抽象的，不占用存储空间；而对象(或者叫实例)是具体的，占用存储空间。

java多线程的总结：http://www.cnblogs.com/lwbqqyumidi/p/3804883.html	！！！！！
Java线程具有五种基本状态：
新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();

就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；

运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。！！！！注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；

阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：
1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；
3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

Java中线程的创建常见有如三种基本形式：
1、继承Thread类
2、继承Runnable接口，并实现run方法
Thread类中对Runnable接口中run()方法的实现：
@Override
public void run() {
      if (target != null) {
          target.run();
      }
  }
一个类继承了Thread类，并且重写了run方法（设为A），而在创建对象（设为t）的时候，又调用了super(B)（B为一个实现了Runnable的接口的run方法），则调用
t.start()时，执行的是A方法，可以从继承并重写去理解

3、使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现call()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。！！！！能够具有返回值，注意这点，切记！！！！！，具体如何实现，现查


就绪状态转换为运行状态：当此线程得到处理器资源
运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源
运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常

由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。---->具体看上面网页里的例子

前面有讲到，当调用了新建的线程的start()方法后，线程进入到就绪状态，可能会在接下来的某个时间获取CPU时间片得以执行，如果希望这个新线程必然性的立即执行，直接调用原来线程的sleep(1)即可，如：
Thread thread = new Thread(myRunnable);
thread.start();
thread.start();
try {
  Thread.sleep(1);   // 使得thread必然能够马上得以执行
   } catch (InterruptedException e) {
   e.printStackTrace();
 }
注：睡一个毫秒级够了，因为CPU不会空闲，会切换到新建的线程。

3.后台线程（Daemon Thread）：
概念/目的：后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。
生命周期：后台线程的生命周期与前台线程生命周期有一定关联。主要体现在：当所有的前台线程都进入死亡状态时，后台线程会自动死亡(其实这个也很好理解，因为后台线程存在的目的在于为前台线程服务的，既然所有的前台线程都死亡了，那它自己还留着有什么用...伟大啊 ! !)。
设置后台线程：调用Thread对象的setDaemon(true)方法可以将指定的线程设置为后台线程
myThread.setDaemon(true);
判断线程是否是后台线程：调用thread对象的isDeamon()方法。
注：main线程默认是前台线程，前台线程创建中创建的子线程默认是前台线程，后台线程中创建的线程默认是后台线程。调用setDeamon(true)方法将前台线程设置为后台线程时，需要在start()方法调用之前。前天线程都死亡后，JVM通知后台线程死亡，但从接收指令到作出响应，需要一定的时间。

4.改变线程的优先级/setPriority()
每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。
常用的有如下三个静态常量值：
MAX_PRIORITY:10
MIN_PRIORITY:1
NORM_PRIORITY:5
注意：！！！！yield()方法还与线程优先级有关，当某个线程调用yiled()方法从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行

线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问

解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。
因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。
使用Lock对象同步锁可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为：
class X {
    
    // 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系
    private final Lock lock = new ReentrantLock();
    public void m(){
        // 加锁
        lock.lock();
        //...  需要进行线程安全同步的代码   
        // 释放Lock锁
        lock.unlock();
    }    
}


五.wait()/notify()/notifyAll()线程通信：
虽然这三个方法主要都是用于多线程中，但实际上都是Object类中的本地方法。因此，理论上，任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信
wait()：导致当前线程等待并使其进入到等待阻塞状态，此时该线程可以理解为放弃了对同步锁对象的锁定，让其他线程可以调用该对象的其他同步方法。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。
notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。
notifyAll()：唤醒在此同步锁对象上等待的所有线程（该对象的所有同步方法，注意：唤醒并不等于执行），这些被唤醒的线程再随机一个获取到同步锁！！！！切记，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。
我们需要注意如下几点：
1.wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行；
2.notify()/notifyAll()方法执行后，将唤醒此同步锁对象上的（任意一个-notify()/所有-notifyAll()）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果notify()/notifyAll()后面还有代码，还会继续进行，知道当前线程执行完毕才会释放同步锁对象；
3.notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2；
4.wait()/notify()/nitifyAll()完成线程间的通信或协作都是基于不同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系；
5.当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。

如果一个线程只调用了notifyAll()方法，且当前cpu时间段还是属于该线程，则会继续执行该线程，不会被其他线程抢占到同步锁，具体看代码理解



java泛型：http://www.cnblogs.com/lwbqqyumidi/p/3837629.html
1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。
2.因此，取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常(及强制类型转换错误)。

什么是泛型？
泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。
如：在List<String>中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）
List接口的的具体定义：public interface List<E> extends Collection<E> 
<E>中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。

自定义泛型接口、泛型类和泛型方法
我们看一个最简单的泛型类和方法定义：
class Box<T> {

    private T data;

    public Box() {

    }

    public Box(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

}
在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，用于接收来自外部使用时候传入的类型实参。
Box<String> name = new Box<String>("corn");
Box<Integer> age = new Box<Integer>(712);
System.out.println("name class:" + name.getClass());      // com.qqyumidi.Box
System.out.println("age class:" + age.getClass());        // com.qqyumidi.Box
System.out.println(name.getClass() == age.getClass());    // true
从上面的例子，我们发现在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。
究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。
对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。

类型通配符
在逻辑上Box<Number>不能视为Box<Integer>的父类，这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是Box<Integer>和Box<Number>的父类的一个引用类型，由此，类型通配符应运而生。

类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box<?>在逻辑上是Box<Integer>、Box<Number>...等所有Box<具体类型实参>的父类。由此，我们依然可以定义泛型方法，来完成此类需求。 public static void getData(Box<?> data) {.....}

类型通配符上限和类型通配符下限:
例如对类型实参又有进一步的限制，只能是Number类及其子类，则此时，需要用到类型通配符上限
形如：Box<? extends Number> data
类型通配符上限通过形如Box<? extends Number>形式定义，相对应的，类型通配符下限为Box<? super Number>形式，其含义与类型通配符上限正好相反

话外篇
在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。并且还要注意的一点是，Java中没有所谓的泛型数组一说。
对于泛型，最主要的还是需要理解其背后的思想和目的。



说起Java，人们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。
JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。

1、Java虚拟机的体系结构
每个JVM都有两种机制：
①类装载子系统：装载具有适合名称的类或接口
②执行引擎：负责执行包含在已装载的类或接口中的指令 

每个JVM都包含：
方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器

Jvm运行机制原理 url:http://blog.csdn.net/u011546655/article/details/52175550，http://www.cnblogs.com/zhouyuqin/p/5161677.html

一、JVM基础概念：
Java虚拟机(Jvm)是可运行Java代码的假想计算机
Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域

二、JVM:
我们都知道Java源文件，通过编译器，能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，也就是前面所有的Java虚拟机中的字节码指令集….编译成特定机器上的机器码
也就是如下：
1.Java源文件—->编译器—->字节码文件
2.字节码文件—->Jvm—->机器码
每一种平台的解释器是不同的，但是实现的虚拟机是相同的。这也就是Java为什么能够跨平台的原因了
当一个程序从开始运行时，这时虚拟机就开始实例化了。多个程序启动就会存在多个虚拟机实例。程序退出或者关闭。则虚拟机实例消亡。多个虚拟机实例之间数据不能共享。

三、Jvm的体系结构
1、垃圾回收器
负责回收内存中无用的对象
2、类装载子系统
一听名字，大家就知道，肯定是用于操作我们编译好的.Class文件的系统，他作用如下：
1.定位和导入二进制class文件 
2.验证导入类的正确性 
3.为类分配初始化内存 
4.帮助解析符号引用

3、执行引擎（Execution Engine）
执行包在装载类的方法中的指令，也就是方法

4、运行区数据
虚拟机内存或者Jvm内存，从整个计算机内存中开辟一块内存存储Jvm需要用到的对象，变量等，运行区数据又分很多小区，分别为：方法区，虚拟机栈，本地方法栈，堆，程序计数器

四、JVM运行时数据区
1.程序计数器
当前线程执行字节码的信号指示器，是线程私有的，它的生命周期和线程相同，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
JVM的多线程是通过线程轮流切换并分配处理器来实现的，对于我们来说的并行事实上一个处理器也只会执行一条线程中的指令。所以，为了保证各线程指令的安全顺利执行，每条线程都有独立的私有的程序计数器
2.虚拟机栈
Java虚拟机栈描述的是Java方法（区别于native的本地方法）执行的内存模型：每个方法被执行的时候都会同时开辟一段内存区域用于存放方法运行时所需的数据，称为栈帧（Stack Frame）用于存储局部变量表、操作栈、动作链接、方法出口等信息。
是线程私有的，生命周期和线程相同，都有各个独立的计数器，各不影响。
每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
3.本地方法栈
和虚拟机方法栈差不多类似，但是本地方法栈是服务于虚拟机所使用到的Native方法服务
4.本地方法区
只执行Native 方法
如果这个区的内存不足也是会抛出StackOverflowError 和OutOfMemoryError 异常

五、堆
堆这块区域是Jvm中最大的，在虚拟机开启的时候创建。应用的对象和数据都是存在这个区域。这块区域也是线程共享的。也是 gc 主要的回收区


java垃圾回收  http://blog.csdn.net/u011546655/article/details/52186044
方法一：引用计数算法
1.给对象添加计数器—>如果引用—>计数器+1 
2.引用失效—>计数器-1 
3.任何时刻计数器为0—对象不能再使用
方法二：根搜索法
1.GC Roots为起点，从这个节点开始向下搜索 
2.所走过的路径，使用Wie引用链 
3.对象到GC Roots没有任何链相连，对象不可用
还有好多知识。。。，需要时再去查阅

JAVA中有两种方法：JAVA方法和本地方法
JAVA方法是由JAVA编写的，编译成字节码，存储在class文件中
本地方法是由其它语言编写的，编译成和处理器相关的机器代码
本地方法保存在动态链接库中，即.dll(windows系统)文件中，格式是各个平台专有的
JAVA方法是与平台无关的，但是本地方法不是，与平台有关

一个本地方法接口——>JAVA本地接口JNI——>使得本地方法可以在特定主机系统的任何一个JAVA平台实现上运行

终止线程的三种方法 
    1.  使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 
    2.  使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。 
    3.  使用interrupt方法中断线程。  这个方法具体查查怎么用
关于第一种：
首先在线程中设置一个标志位：
public volatile boolean exit = false; 
然后在run方法中加上一个while循环：
public void run() 
{ 
   while (!exit){
	dosomework；
} 
} 
在上面代码中定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false.在定义exit时，使用了一个 Java关键字volatile，这个关键字的目的是使exit同步，也就是说在同一时刻只能由一个线程来修改exit的值
在需要让线程停止的时候，调用thread.exit = true; 来停止，该方法没有办法做到立刻停止，只有到达下一次while循环时，通过判断exit的值，才会让线程停止
要做到立即终止线程，且安全退出，可以借助1和3两种方法结合使用完成
在需要终止线程的时候，调用 thread.shutdown();
这个模式中采用了两个步骤来终止线程，所以叫两步终止模式。第一步，先将执行标志位shutdownRequested 设为false，是作业中的线程转变为终止处理中的状态，第二部才是真正去执行终止操作。这样的做法可以保证线程的安全性、生命性和响应性。
public void shutdown() {
    exit = true;
    interrupt();
}
安全性：不会在线程正在执行关键区域--Critical Section的时候突然结束掉
生命性：一定会进行终止处理，shutdown()中，会调用interrupt()，保证即使线程处于sleep或wait状态也可以被立即终止，而客户端调用shutdown()之后，会调用join()(用来等待线程关闭)，保证了这个线程会执行完，也就确保了终止操作doshutdown()一定会执行
响应性：将shutdownRequested 设为volatile ，能保证线程收到终止请求后，会尽快开始终止处理。


线程池(Thread pool)是池技术的一种，就是在程序启动时首先把需要个数的线程对象创建好，例如创建5000个线程对象，然后当客户端连接到达时从池中取出一个已经创建完成的线程对象使用即可。当客户端连接关闭以后，将该线程对象重新放入到线程池中供其它的客户端重复使用，这样可以提高程序的执行速度，优化程序对于内存的占用等。具体如何实现的，再百度看看


流的概念：url：http://www.cnblogs.com/xll1025/p/6418675.html
在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。
程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。
字节流与字符流
在Java.io包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。（这四个都是抽象类）
InputStream 和OutputStream,两个是为字节流设计的,主要用来处理字节或二进制对象,
Reader和 Writer.两个是为字符流（一个字符占两个字节）设计的,主要用来处理字符或字符串.

字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！
字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的
字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容（这部分指写操作时！！！！！！！）


注意在IO流中使用readline()这个方法的时候，是会把换行符舍去，只保留前面的部分，
所以如果在读取时是用readline()，则在写入的字符串也是用readline()获取的，则最后应该要加上newline()，否则会造成阻塞,一直在等待换行符！！！！
尤其在网络通信的时候


线程的工作原理：
jvm有一个main   memory，而每个线程有自己的working   memory，一个线程对一个variable进行操作时，都要在自己的working   memory里面建立一个copy，操作完之后再写入main   memory。多个线程同时操作同一个variable，就可能会出现不可预知的结果。

线程安全就是说多线程访问同一代码，不会产生不确定的结果。编写线程安全的代码是低依靠线程同步。
使用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你认为合适的object比如method，
通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完   load到workingmemory   －>   use&assign   －>   store到mainmemory   的过程，才会释放它得到的锁。这样就实现了所谓的线程安全。

线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据
五类线程安全性的分类方法：不可变、线程安全、有条件线程安全、线程兼容和线程对立。

对于Linux内核而言，进程和线程之间的区别并不大（也可用于python的进程解释），线程也不过是共享内存空间的进程。每个线程都是一个轻量级进程(Light Weight Process),都有自己的唯一PID(或许叫TID更合适一些)和一个TGID(Thread group ID),TGID是启动整个进程的thread的PID.
简单来说，当一个进程被创建的时候，它其实是一个PID和TGID数值相同线程。当线程A启动线程B时，线程B会有自己的唯一PID，但它的TGID会从A继承而来。这样通过PID线程可以独立得到调度，而相同的TGID可以知道哪些线程属于同一个进程，这样可以共享资源(RAM，虚拟内存、文件等)。！！！！！

IO操作阻塞的时候，是不需要cpu参与的，这时候cpu就可以另开一个线程去做别的事情，等待IO操作完成再回到之前的线程继续执行

多线程全部总结：http://www.cnblogs.com/wxd0108/p/5479442.html
并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力
Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用
wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。
当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。
Thread类最佳实践：
写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。
不能用try,catch来获取线程中的异常
Callable	//具体百度看看如何使用！！！！！！！
future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态
ExecutorService e = Executors.newFixedThreadPool(3);
 //submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.
Future future = e.submit(new myCallable());
future.isDone() //return true,false 无阻塞
future.get() // return 返回值，阻塞直到该线程运行结束


高级多线程控制类：
1.ThreadLocal类
用处：保存线程的独立变量。对一个线程类（继承自Thread)
当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。
实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。
主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -> a，get时将a返回。ThreadLocal是一个特殊的容器。

2.原子类（AtomicInteger、AtomicBoolean……）具体百度
3.Lock类
lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序）
提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。
本质上和监视器锁（即synchronized是一样的）
能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。
和Condition类的结合。
性能更高
4.容器类
5.管理类
管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。
了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean，ThreadPoolExecutor


从JVM角度看多线程：http://blog.csdn.net/clj198606061111/article/details/54897292
java里的变量可以分3类：
1、类变量（类里面static修饰的变量）
2、实例变量（类里面的普通变量）
3、局部变量（方法里声明的变量）
根据各个区域的定义，我们可以知道： 
1. 类变量 保存在“方法区” 
2. 实例变量 保存在“堆” 
3. 局部变量 保存在 “虚拟机栈”
“方法区”和“堆”都属于线程共享数据区，“虚拟机栈”属于线程私有数据区
在java中，多线程间进行通信的唯一途径就是通过类变量和实例变量。也就是说，如果一段多线程程序中如果没有类变量和实例变量，那么这段多线程程序就一定是线程安全的。
把实例变量改为ThreadLocal变量，而ThreadLocal实现的含义就是让实例变量变成了“线程私有”的，即给每一个线程分配一个自己的值。这种方式并不是真正的共享，而是为每个线程分配一个自己的值。
每个java线程都有一份自己的工作内存，线程访问变量的时候，不能直接访问主内存中的变量，而是先把主内存的变量复制到自己的工作内存，然后操作自己工作内存里的变量，最后再同步给主内存。
例如a++可以分解为3步操作：
1、把主内存里的a复制到线程的工作内存
2、线程对工作内存里的a执行a=a+1
3、把线程工作内存里的a同步回主内存

同步基本思想：
为了保证共享数据在同一时刻只被一个线程使用，我们有一种很简单的实现思想，就是在共享数据里保存一个锁，当没有线程访问时，锁是空的，当有第一个线程访问时，就在锁里保存这个线程的标识并允许这个线程访问共享数据。在当前线程释放共享数据之前，如果再有其他线程想要访问共享数据，就要等待锁释放。
我们把这种思想的三个关键点抽出来：
1、在共享数据里保存一个锁
2、在锁里保存这个线程的标识
3、其他线程访问已加锁共享数据要等待锁释放

synchronized有三种用法：一种是同步块，这种用法需要指明一个锁定对象；一种是修饰静态方法，这种用法相当于锁定Class对象；一种是修饰普通方法，这种用法相当于锁定方法所在的实例对象。因此，在java里能够被synchronized关键字锁定的一定是对象，因此就要在对象里保存一个锁


第三方包：HttpClient：http://blog.csdn.net/moshenglv/article/details/51973370
HttpClient 功能介绍
　　以下列出的是 HttpClient 提供的主要的功能，要知道更多详细的功能可以参见 HttpClient 的主页。
　　（1）实现了所有 HTTP 的方法（GET,POST,PUT,HEAD 等）
　　（2）支持自动转向
　　（3）支持 HTTPS 协议
　　（4）支持代理服务器等





