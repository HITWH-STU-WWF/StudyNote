1、字节与字符
字节与字符属于不同概念：
字节：一字节有8位
字符：我们使用的符号，字母，文字等，一个字符在不同的编码方式中由不同数量的字节构成，如在utf8中，一个英文字母或数字占一字节，一个汉字占的字节数不固定

2、进程和线程以及协程   url:http://www.jb51.net/article/60728.htm
进程是计算机中已运行程序的实体。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；
在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。	#线程——>进程
程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。
线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行(即同时)执行不同的任务。
进程，是程序运行的实体，这句话的意思是，程序是存放在硬盘中的，当这个程序运行时，就会产生若干个进程，并且这个进程是可见的
总结:  一个进程中至少有一个线程，在实际的工作中，不是所有的程序都支持多线程，也有一些程序对多进程也支持得不够好，像PHP，Node.js等都是单进程，单线程的。
在python中，一般使用thread取创建线程

协程：
所谓协程，就是同时开启多个任务，但一次只顺序执行一个。等到所执行的任务遭遇阻塞，就切换到下一个任务继续执行，以期节省下阻塞所占用的时间。而多线程就是纯粹的并发模型了，同时执行多个任务，系统每次处理多个任务递交的请求之一，类似于边吃饭边喝水的意思。单进程下协程和多线程区别并没有很大，而多进程下，多线程可以利用多核资源，这是单进程的协程模型做不到的。

协程是在一个线程执行过程中可以在一个子程序的预定或者随机位置中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。他本身是一种特殊的子程序或者称作函数。

3、I/O多路复用	url：https://www.zhihu.com/question/32163005
你有N个不知道什么时候来水的水龙头需要接水，你根据某种信号一会儿拧这个龙头，一会儿拧那个龙头把水都接了就是多路复用（一个线程）。使用残像拳在每个水龙头前派一个你的分身蹲守就是Threadeds IO（多线程IO）。其实后者也没啥不好，因为未来的内核会消除上下文切换的软硬件性能损耗

UNIX有5种I/O模型,阻塞会发生在两个阶段上:
1.阻塞式I/O    等待数据时阻塞   数据从内核复制到用户空间时阻塞
2.非阻塞式I/O 等待数据不阻塞,但是轮询会占用cpu资源 数据从内核复制到用户空间时阻塞
3.I/O复用  考虑到轮询占用cpu资源的问题,阻塞在选择器上,减轻处理器负担  将数据从内核复制到用户空间时阻塞
4.信号驱动式I/O 等待数据不阻塞,数据准备好时通知接收数据,将数据从内核复制到用户空间时阻塞
以上四种或多或少均有阻塞现象存在,它们都是同步I/O模型
5.异步I/O 等待数据时不阻塞 将数据从内核复制到用户空间时也不阻塞. 数据到了用户空间以后才发信号,就像你在网上下了订单,快递员拿着你的快件站在你家门口才通知你开门签收的样子.
而在网上下了订单,货物到了离你家最近的自提点,商城通知你去自提点取提货.你专门抽出时间去提货.这是4.信号驱动式I/O.因为在来回自提点的路上你其实是阻塞的

4、str and bytes 区别：
Python3最重要的新特性之一是对字符串和二进制数据流做了明确的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python3不会以任意隐式的
方式混用str和bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然）
最早的字符编码规范是ASCII码，一种8位即1个字节的编码规范，它可以涵盖整个英语系的编码需要。
标准组织制定出了叫做UNICODE的万国码，它规定任何一个字符（不管哪国的）至少以2个字节表示，可以更多。
UTF-8编码应运而生，它规定英文字母系列用1个字节表示，汉字用3个字节表示等等。
bytes是一种比特流
s='中国'
b = bytes(s, encoding='utf-8')
b实际上是一串01的组合，但为了在ide环境中让我们相对直观的观察，它被表现成了b'\xe4\xb8\xad\xe6\x96\x87'这种形式，开头的b表示这是一个bytes类型。\xe4是十六进制的表示方式，它占用1个字节的长度，因此”中文“被编码成utf-8后，我们可以数得出一共用了6个字节，每个汉字占用3个，这印证了上面的论述。在使用内置函数bytes()的时候，必须明确encoding的参数，不可省略。
字符串类str里有一个encode()方法，它是从字符串向比特流的编码过程。而bytes类型恰好有个decode()方法，它是从比特流向字符串解码的过程
从实质上来说，字符串在磁盘上的保存形式也是01的组合，也需要编码解码。

在将字符串存入磁盘和从磁盘读取字符串的过程中，Python自动地帮你完成了编码和解码的工作，你不需要关心它的过程。
使用bytes类型，实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。
Python已经严格区分了bytes和str两种数据类型，你不能在需要bytes类型参数的时候使用str参数，反之亦然。这点在读写磁盘文件时容易碰到。
在bytes和str的互相转换过程中，实际就是编码解码的过程，必须显式地指定编码格式。
字节转化为字符串是解码过程，字符串转成字节是编码过程,字符串没有解码的函数
英文句子可以直接用字节表示，如：b'nihao wo shi wwf'，因为一个英文字母占有一个字节，跟字节的表示方法（一个字节一个字节的表示）一样，所以可以，而中文就不能直接b'你好'，切记这点(原因是自己猜测的)


5、tcp和udp协议
TCP协议和UDP协议发送和接收的数据都是字节（bytes），所以需要对接受的数据进行解码(decode)，对发送的数据进行编码(encode)

一个TCP连接必须要经过三次“对话”才能建立起来
first:我想向你发数据可以吗？	A-->B
second：可以，你什么时候发	B-->A
third: 我现在就发，准备接收	A-->B
然后A开始发送数据

TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。
使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。
虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。
UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。------重点！！！


cpu内部架构和工作原理：url：http://blog.chinaunix.net/uid-23069658-id-3563960.html

IO操作时：
排序（连续）处理（即一个一个来）很常见，除了硬盘的数据io(如文件读写，数据库查询等)还有CPU和内存的io，网络之间的io则趋向于并发处理，由于并发处理的不确定性所以引发的io异常相当的多
对于排序处理的IO操作，并不能通过代码实现减少在IO操作上花费的时间！！！！这点切记，而对于并发处理的IO，可以利用多线程/多进程减少花费在IO操作上的时间，因为可以理解为，电脑就一个硬盘/内存，无论开多少个进程/线程都无法做到同时对硬盘/内存的读写，而网络的IO操作，大多时间都花费在等待相应的阶段和接受数据的阶段，这是可以做同时发送，依次等待接收的

总之，计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。

什么时候该使用多线程呢？这要分四种情况讨论：
a.多核CPU——计算密集型任务。此时要尽量使用多线程，可以提高任务执行效率，例如加密解密，数据压缩解压缩（视频、音频、普通数据），否则只能使一个核心满载，而其他核心闲置。
b.单核CPU——计算密集型任务。此时的任务已经把CPU资源100%消耗了，就没必要也不可能使用多线程来提高计算效率了；相反，如果要做人机交互，最好还是要用多线程，避免用户没法对计算机进行操作。
c.单核CPU——IO密集型任务，使用多线程还是为了人机交互方便，
d.多核CPU——IO密集型任务，这就更不用说了，跟单核时候原因一样。
4.程序员需要掌握的技巧/技术
(1)减少串行化的代码用以提高效率。这是废话。
(2)单一的共享数据分布化：把一个数据复制很多份，让不同线程可以同时访问。
(3)负载均衡，分为静态的和动态的两种。具体的参见有关文献。


python编译后的字节码是特定于Python的一种表现形式，它不是二进制的机器码，需要进一步编译才能被机器执行，这也是Python代码无法运行的像C/C++ 一样快的原因。如果Python进程在机器上拥有写入权限，那么它将把程序的字节码保存为一个以.pyc 为扩展名的文件

python的第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。

python的第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。





一、各自的定义
标记语言
标记语言，是一种将文本（Text）以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。与文本相关的其他信息（包括例如文本的结构和表示信息等）与原来的文本结合在一起，但是使用标记（markup）进行标识。如：HTML、XML
脚本语言
脚本语言是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。它的命名起源于一个脚本“screenplay”，每次运行都会使对话框逐字重复。早期的脚本语言经常被称为批量处理语言或工作控制语言。 一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。如：JavaScript、VBScript、PHP编译型语言
编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++
二、区别
1、标记语言不用于向计算机发出指令，常用于格式化和链接。
2、脚本语言介于标记语言和编程语言之间，脚本语言脚本语言不需要编译，可以直接用，由解释器来负责解释。 （可以近似理解程脚本语言是解释型语言（不一定对），而编程语言是编译型语言）
3、编译型语言写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。



垃圾回收机制：
现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患
python里同java一样采用了垃圾收集机制，不过不一样的是，python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略
引用计数为0时，该对象生命就结束了。
引用计数机制的优点：
	1、简单
	2、实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。        
引用计数机制的缺点： 
	1、维护引用计数消耗资源 
	2、循环引用 
python里回收机制是以引用计数为主，标记-清除和分代收集两种机制为辅


java部分！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

一、JDK、JRE、JVM的区别：
1、JRE（Java Runtime Environment  java运行环境）	JVM-->JRE	
包括JAVA虚拟机和JAVA程序所需的核心类库，如果想要运行一个开发好的JAVA程序，计算机中只要安装JRE即可
2、JDK（Java Development  toolKit  java开发工具包）	JVM-->JRE-->JDK	
JDK是提供给JAVA开发人员使用的，其中包含了JAVA的开发工具，也包括了JRE。所以安装了JDK，就不用再单独安装JRE了
3、JVM(java Virtual Machine Java虚拟机)
Java号称是一次编写，到处运行。也就是说，Java程序可以实现跨平台，在Windows上写好的Java程序，可以运行在Linux或者其它平台上面，而不用修改源代码。而C或者C++就不行了，他是跟平台相关的。Java只所以能够跨平台，是因为Java程序不是直接运行在操作系统上的，而是运行在JVM上的。而JVM根据不同的操作系统，有不同的版本，比如有Linux版本的，Windows版本的等。我们在安装JRE或者JDK的时候，需要根据操作系统来下载不同的版本，而JDK和JRE里面已经包括了JVM，上面也说过了。所以，Java程序才能够实现跨平台！！！！这点切记

二、JAVA语言的三种结构（JAVASE,JAVAEE,JAVAME）
1、J2EE(Java 2 Platform Enterprise Edition) 企业版javaee
是为开发企业环境下的应用程序提供的一套解决方案。 该技术体系中包含的技术如 Servlet Jsp等，主要针对于Web应用程序开发。可以使用一些现有的框架来快速的做企业网站的开始，比如SSH框架
2、J2SE（Java 2 Platform Standard Edition）标准版javase	---------->是基础	
是为开发普通桌面和商务应用程序提供的解决方案。 该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发。 比如Java版的扫雷。它是学习J2EE或J2ME的基础！！！！，主要包括了Java的基本语法规范，面向对象等内容。
3、J2ME(Java 2 Platform Micro Edition) 小型版javame
是为开发电子消费产品和嵌入式设备提供的解决方案。 该技术体系主要应用于小型电子消费类产品，如手机中的应用程序等。
Java5.0版本后，更名为 JAVAEE    JAVASE    JAVAME

JavaWeb与J2EE的区别：
   J2EE是Java的企业应用开发，涵盖了B/S和C（Client客户端）/S（Server服务器），注重的是结构和框架，我们所熟知的struts2、hibernate和spring即ssh就是j2ee的一些基本框架。
   JavaWeb是指Java在B（Browser浏览器）/S（Server服务器）方面的开发，做的是网络应用；

单精度与双精度
含义：表明单精度和双精度精确的范围不一样，单精度，也即float，一般在计算机中存储占用4字节，也32位，有效位数为7位；双精度（double）在计算机中存储占用8字节，64位，有效位数为16位。原因：不管float还是double 在计算机上的存储都遵循IEEE规范，使用二进制科学计数法，都包含三个部分：符号位，指数位和尾数部分。其中float的符号位，指数位，尾数部分分别为1,  8,  23.     双精度分别为1,  11,  52。精度主要取决于尾数部分的位数，float为23位，除去全部为0的情况以外，最小为2的-23次方，约等于1.19乘以10的-7次方，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。  类似，double 尾数部分52位，最小为2的-52次方，约为2.22乘以10的-16次方，所以精确到小数点后15位，有效位数为16位。

java中的内存空间 url:http://blog.csdn.net/tutngfei1129287460/article/details/7383473
1、寄存器	我们在程序中无法控制
2、栈		存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中
3、堆		通过new创建的，都是在堆中进行分配的，存放用new产生的数据
4、静态存储区	存放在对象中用static定义的静态成员
5、常量存储区	final static 声明的，就属于常量存储区 ，且有一个专门的String常量池，存放常量
6、非RAM存储：	硬盘等永久存储空间

因为上述的原因，所以string a="hello" 	String b=new String("hello")   a 和 b存储在不同的存储空间！！！！！这个注意
在常量池中，相同内容的变量只有一个，只要存在，就不会创建新的，不存在，则创建新的，所有如果有多个相同的字符串对象（存储在常量区的），所指向的内存是同一个地址

栈：
在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配
当在一段代码块定义一个变量时，Java就在栈中 为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用

堆：
堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。  引用变量就相当于是 为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称！！！！！。如 Student a=new Student() 	a是在栈中分配空间的，而真正的Student是存在于堆中的
引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序 运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍 然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。！！！！！！！！！！！
实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！

常量池 (constant pool)
常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值(final)还包含一些以文本形式出现的符号引用，比如：
◆类和接口的全限定名；
◆字段的名称和描述符；
◆方法和名称和描述符。
虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和 floating point常量）和对其他类型，字段和方法的符号引用。
对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的， 对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用（及引用的对象）。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。
在程序执行的时候,常量池 会储存在Method Area,而不是堆中。

栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：
1. int a = 3;   
2. int b = 3；  
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。
这时，如果再令 a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响 到b的值。

要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。
String是一个特殊的包装类数据。可以用：
String str = new String("abc");   
String str = "abc";  
两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对String类的对象引用变量str，然后通过符号引用去字符串常量池 里找有没有"abc",如果没有，则将"abc"存放进字符串常量池 ，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。
用new的方式是生成不同的对象。每一次生成一个。
注意：！！！！！！！！！
1. 首先String不属于8种基本数据类型，String是一个对象。因为对象的默认值是null，所以String的默认值也是null；但它又是一种特殊的对象，有其它对象没有的一些特性。
2. new String()和new String("")都是申明一个新的空字符串，是空串不是null；
3. String str=”kvill”；String str=new String (”kvill”)的区别

String的 intern()方法就是扩充常量池的 一个方法；当一个String实例str调用intern()方法时，Java 查找常量池中 是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常 量池中增加一个Unicode等于str的字符串并返回它的引用；

要知道String的实例一旦生成就不会再改变了，比如说：String str=”kv”+”ill”+” “+”ans”; 就是有4个字符串常量，首先”kv”和”ill”生成了”kvill”存在内存中，然后”kvill”又和” ” 生成 “kvill “存在内存中，最后又和生成了”kvill ans”;并把这个字符串的地址赋给了str,就是因为String的”不可变”产生了很多临时变量，这也就是为什么建议用StringBuffer的原 因了，因为StringBuffer是可改变的。

String中的final用法和理解（对于其他变量是否如此，自己尝试,好像也是成立的）
final只对引用的"值"(即内存地址)有效，它迫使引用只能指向初始指向的那个对象，改变它的指向会导致编译期错误。至于它所指向的对象 的变化，final是不负责的。
如：
 final StringBuffer a = new StringBuffer("111");
 final StringBuffer b = new StringBuffer("222");
 a=b;//此句编译不通过。因为要改变a的引用地址
 final StringBuffer a = new StringBuffer("111");
 a.append("222");// 编译通过，不改变a的引用地址，只改变引用对象的值

String  s  =  "a" + "b" + "c"; 
 就等价于String s = "abc";  
 String  a  =  "a";   
 String  b  =  "b";   
 String  c  =  "c";   
 String  s  =   a  +  b  +  c; 
这个就不一样了，最终结果等于：
1．StringBuffer temp = new StringBuffer();     
2．temp.append(a).append(b).append(c);     
3．String s = temp.toString(); 
由上面的分析结果，可就不难推断出String 采用连接运算符（+）效率低下原因！！！！！





python动态类型	url:http://www.cnblogs.com/vamei/archive/2012/07/10/2582795.html
动态类型(dynamic typing)是Python另一个重要的核心概念。我们之前说过，Python的变量(variable)不需要声明，而在赋值时，变量可以重新赋值为任意值。这些都与动态类型的概念相关
对象是储存在内存中的实体。但我们并不能直接接触到该对象。我们在程序中写的对象名，只是指向这一对象的引用(reference)
引用和对象分离，是动态类型的核心！！！！！！！！！
a = 3
a = 'at'
对象3不再有引用指向它。Python会自动将没有引用指向的对象销毁(destruct)，释放相应内存。
(对于小的整数和短字符串，Python会缓存这些对象，而不是频繁的建立和销毁。)
注意以下情况：！！！
L1 = [1,2,3]
L2 = L1
L1[0] = 10
print L2
在该情况下，我们不再对L1这一引用赋值，而是对L1所指向的表的元素赋值。结果是，L2也同时发生变化。
原因何在呢？因为L1，L2的指向没有发生变化，依然指向那个表。表实际上是包含了多个引用的对象（每个引用是一个元素，比如L1[0]，L1[1]..., 每个引用指向一个对象，比如1,2,3), 。而L1[0] = 10这一赋值操作，并不是改变L1的指向，而是对L1[0], 也就是表对象的一部份(一个元素)，进行操作，所以所有指向该对象的引用都受到影响。

列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。
而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。
我们之前学的元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object.


从动态类型看函数的参数传递:！！！！！！！！！！！！！与java的机制很相似，不可变对象类似java中的8大基本数据类型，可变对象类似java中的对象
函数的参数传递，本质上传递的是引用。比如说：
def f(x):
    x = 100
    print x
a = 1
f(a)
print a
参数x是一个新的引用，指向a所指的对象。如果参数是不可变(immutable)的对象，a和x引用之间相互独立。对参数x的操作不会影响引用a。这样的传递类似于C语言中的值传递。
如果传递的是可变(mutable)的对象，那么改变函数参数，有可能改变原对象。所有指向原对象的引用都会受影响，编程的时候要对此问题留心。比如说：
def f(x):
    x[0] = 100
    print x
a = [1,2,3]
f(a)
print a

python的内存管理	url:http://www.cnblogs.com/vamei/p/3232088.html
对象与引用分离。Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——>对象
Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址
在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。
由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象,如下：
# True
a = 1
b = 1
print(a is b)

# True
a = "good"
b = "good"
print(a is b)

# False
a = "very good morning"
b = "very good morning"
print(a is b)

# False
a = []
b = []
print(a is b)


在Python中，每个对象都有存有指向该对象的引用总数，即引用计数。
我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。
from sys import getrefcount
a = [1, 2, 3]
print(getrefcount(a))
b = a
print(getrefcount(b))
由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2

对象引用对象
Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用
我们也可以自定义一个对象，并引用其它对象:
class from_obj(object):
    def __init__(self, to_obj):
        self.to_obj = to_obj
b = [1,2,3]
a = from_obj(b)
print(id(a.to_obj))
print(id(b))
可以看到，a引用了对象b
对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值"a"的元素引用整数对象1。该词典对象用于记录所有的全局引用！！！（注意是记录所有的全局引用，要求是全局的）。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。

某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用	a = [1, 2, 3]  b = a  del a
del也可以用于删除容器元素中的元素	a = [1,2,3]	del a[0]

python的垃圾回收机制：从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。
垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动
我们可以通过gc模块的get_threshold()方法，查看该阈值:
import gc
print(gc.get_threshold())
返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。
我们也可以手动启动垃圾回收，即使用gc.collect()。

分代回收
Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。

孤立的引用环	具体再百度,或者看上面那个文章自己再理解以下，按照孤立的引用环的回收机制,如果只存在互相引用，而不存在其他对象的引用，则这两个对象的引用次数是相等的，可以假设为1，则按照这个机制，进行遍历后，两个对象的gc_ref都将等于0，则被回收
引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。

WEB服务器、应用程序服务器、HTTP服务器有何区别：
Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL。与客户端的网络浏览器配合。因为Web服务器主要支持的协议就是HTTP，所以通常情况下HTTP服务器和WEB服务器是相等的(有没有支持除HTTP之外的协议的web服务器，作者没有考证过)，说的是一回事
Web服务器传送(serves)页面使浏览器可以浏览，然而应用程序服务器提供的是客户端应用程序可以调用(call)的方法(methods)。确切一点，你可以说:Web服务器专门处理HTTP请求(request)，但是应用程序服务器是通过很多协议来为应用程序提供(serves)商业逻辑 (business logic)。


常见的web服务器：Apache和Nginx(linux平台) IIS（window平台）
很多小公司小项目目前不一定使用了web服务器，因为流量下，单台应用服务器可以支撑。

实际工作中，我所体会的web服务器的作用：
1. 负载均衡（其中还提供session的支持，比如一个用户IP访问的是应用的A机器，他之后的请求都会请求道A机器）
2. 代理转发请求一下，更安全些，不直接暴露应用服务器IP给对方，因为应用服务器里面有代码等等
3. web服务器可以统一统计和处理所以请求，比如有日志记录所有被访问的url，以及统计。
4. web服务器还可以针对不同的url转发到不同应用服务器地址。
比如aaa.com/bbb/ccc.html转发A应用服务器；aaa.com/ddd/ccc.html转发B应用服务器
5. 可以对应用服务器抛出的所有503等所有错误页面统一跳入它自己设置的html页面，或者调至统一的错误异常系统里面去。

6. 应用服务器迁移，或者IP更换的时候，只需要在web服务器上面配置即可。便于统一管理
缺点：
1. 每次请求都多走了一次网络开销。慢。
2. 维护更麻烦。



分布式与集群的联系与区别：url：http://os.51cto.com/art/201408/448272.htm
区别：
一句话：分布式是并联工作的，集群是串联工作的。
分布式是指将不同的业务分布在不同的地方。 而集群指的是将几台服务器集中在一起，实现同一业务。
分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。
简单说，分布式是以缩短单个任务的执行时间（将单个任务分成多个小部分，并行执行，最后再汇总）来提升效率的，而集群则是通过提高单位时间内执行的任务数（原本一个服务器单位时间处理n个任务，现在有5个相同的服务器，则单位时间变成可处理5n个任务）来提升效率。

集群概念：
两大关键特性：	
可扩展性（新的服务实体可以动态地加入到集群）；	高可用性（如果一个服务实体出错，可转由另外一个服务实体进行服务）；
两大能力：
负载均衡（负载均衡能把任务比较均衡地分布到集群环境下的计算和网络资源）；错误恢复（执行某个任务的资源出现故障，另一服务实体中执行同一任务的资源接着完成任务）
两大技术：
集群地址：集群由多个服务实体组成，集群客户端通过访问集群的集群地址获取集群内部各服务实体的功能。具有单一集群地址（也叫单一影像）是集群的一个基 本特征。维护集群地址的设置被称为负载均衡器
内部通信：为了能协同工作、实现负载均衡和错误恢复，集群各实体间必须时常通信，比如负载均衡器对服务实体心跳测试信息、服务实体间任务执行上下文信息的通信。

Linux集群主要分成三大类( 高可用集群， 负载均衡集群，科学计算集群)


Linux优化mysql查询：http://os.51cto.com/art/201407/446750.htm
总结
CPU方面：
关闭电源保护模式
内存：
vm.swappiness = 0
关闭numa
文件系统：
用noatime，nobarrier挂载系统
IO调度策略修改为deadline。


采用多进程编程，基本提高不了文件IO的速度！！！,只能提高一点点速度而已
但是对于数据库的操作可以（前提是不涉及锁的排斥，且采用连接池或者创建多个连接实例，具体看mysql笔记）


网络编程：！！！！！！！！！url:http://blog.csdn.net/he90227/article/details/39184247
网络编程的实质就是两个(或多个)设备(例如计算机)之间的数据传输。
由于IP地址不容易记忆，所以为了方便记忆，有创造了另外一个概念——域名(Domain Name)，例如sohu.com等。一个IP地址可以对应多个域名，一个域名只能对应一个IP地址
在网络中传输的数据，全部是以IP地址作为地址标识，所以在实际传输数据以前需要将域名转换为IP地址，实现这种功能的服务器称之为DNS服务器，也就是通俗的说法叫做域名解析。例如当用户在浏览器输入域名时，浏览器首先请求DNS服务器，将域名转换为IP地址，然后将转换后的IP地址反馈给浏览器，然后再进行实际的数据传输。
当DNS服务器正常工作时，使用IP地址或域名都可以很方便的找到计算机网络中的某个设备，例如服务器计算机。当DNS不正常工作时，只能通过IP地址访问该设备。所以IP地址的使用要比域名通用一些。
IP地址和域名很好的解决了在网络中找到一个计算机的问题，但是为了让一个计算机可以同时运行多个网络程序，就引入了另外一个概念——端口(port)。
审讯的时候，警察问一句，嫌疑犯回答一句，如果警察不问，则嫌疑犯保持沉默。这种一问一答的形式就是网络中的“请求-响应”模型。也就是通讯的一端发送数据，另外一端反馈数据，网络通讯都基于该模型。
在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)程序，简称客户端，而在第一次通讯中等待连接的程序被称作服务器端(Server)程序，简称服务器。一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。
在开发时需要分别开发客户端和服务器端，这种网络编程的结构被称作客户端/服务器结构，也叫做Client/Server结构，简称C/S结构
使用通用的客户端，例如浏览器，使用浏览器作为客户端的结构被称作浏览器/服务器结构，也叫做Browser/Server结构，简称为B/S结构
C/S结构和B/S结构是现在网络编程中常见的两种结构，B/S结构其实也就是一种特殊的C/S结构
介绍一下P2P(Point to Point)程序，常见的如BT、电驴等。P2P程序是一种特殊的程序，应该一个P2P程序中既包含客户端程序，也包含服务器端程序
网络中传输的数据格式在网络编程中就被称作协议。
只要按照一种协议格式能够生成唯一的编码，按照该编码可以唯一的解析出发送数据的内容即可。也正因为各个网络程序之间协议格式的不同，所以才导致了客户端程序都是专用的结构。
在实际的网络程序编程中，最麻烦的内容不是数据的发送和接收，因为这个功能在几乎所有的程序语言中都提供了封装好的API进行调用，最麻烦的内容就是协议的设计以及协议的生产和解析，这个才是网络编程中最核心的内容。
在现有的网络中，网络通讯的方式主要有两种：
1、 TCP(传输控制协议)方式  三次握手
2、 UDP(用户数据报协议)方式
为了方便理解这两种方式，还是先来看一个例子。大家使用手机时，向别人传递信息时有两种方式：拨打电话和发送短信。使用拨打电话的方式可以保证将信息传递给 别人，因为别人接听电话时本身就确认接收到了该信息。而发送短信的方式价格低廉，使用方便，但是接收人有可能接收不到。
在网络通讯中，TCP方式就类似于拨打电话，使用该种方式进行网络通讯时，需要建立专门的虚拟连接，然后进行可靠的数据传输，如果数据发送失败，则客户端会自动重发该数据。而UDP方式就类似于发送短信，使用这种方式进行网络通讯时，不需要建立专门的虚拟连接，传输也不是很可靠，如果发送失败则客户端无法获得。

客户端网络编程步骤：
1、建立网络连接
2、交换数据（一般会重复多次）
3、关闭网络连接

服务端网络编程步骤：
1、监听端口
2、获得连接
3、交换数据
4、关闭连接
这就是服务器端编程的模型，只是TCP方式是需要建立连接的，对于服务器端的压力比较大，而UDP是不需要建立连接的，对于服务器端的压力比较小罢了。
TCP:实际的网络传输中，如果发送的一方发送的数据接收方觉得有问题，则网络底层会自动要求发送方重发，直到接收方收到为止。


网络协议：
网络协议是指对于网络中传输的数据格式的规定。
网络协议的实质也是客户端程序和服务器端程序对于数据的一种约定，只是由于以计算机为基础，所以更多的是使用数字来代表内容，这样就显得比较抽象一些。
网络协议就是一种格式上的约定，可以根据逻辑的需要约定出各种数据格式，在进行设计时一般遵循“简单、通用、容易解析”的原则进行。
对于复杂的网络程序来说，需要传输的数据种类和数据量都比较大，这样只需要依次设计出每种情况下的数据格式即可，例如QQ程序，在该程序中需要进行传输的网络数据种类很多，那么在设计时就可以遵循：登录格式、注册格式、发送消息格式等等，一一进行设计即可。所以对于复杂的网络程序来说，只是增加了更多的命令格式，在实际设计时的工作量增加不是太大。
在网络编程中，对于同一个网络程序来说，一般都会涉及到两个网络协议格式：客户端发送数据格式和服务器端反馈数据格式，在实际设计时，需要一一对应。这就是最基本的网络协议的知识。
客户端程序需要完成的处理为：
1、 客户端发送协议格式的生成
2、 服务器端反馈数据格式的解析
服务器端程序需要完成的处理为：
1、 服务器端反馈协议格式的生成
2、 客户端发送协议格式的解析
由于各种网络程序使用不同的协议格式，所以不同网络程序的客户端之间无法通用。
对于常见协议的格式，例如HTTP(Hyper Text Transfer Protocol，超文本传输协议)、FTP(File Transfer Protocol，文件传输协议)，SMTP(Simple Mail Transfer Protocol，简单邮件传输协议)等等，都有通用的规定，具体可以查阅相关的RFC文档
对于一种网络程序来说，网络协议格式是该程序最核心的技术秘密，因为一旦协议格式泄漏，则任何一个人都可以根据该格式进行客户端的编写，这样将影响服务器端的实现，也容易出现一些其它的影响。



内网与外网：http://blog.csdn.net/w124374860/article/details/52641851
简单点说：
我们自己的单位或者家庭、小区内部有局域网；单位、家庭之外有覆盖范围极大的网络，比如internet，这个大网络延伸到了我们的单位、家庭（通过光纤、网线、电话线等）。我们把自己的局域网连接到internet上，那么我们的访问范围就从局域网扩展到了整个internet。这时候，就说局域网是内网，internet是外网。
同理，如果你们单位的局域网很庞大，而你的办公室里面的几台电脑组成的小局域网又连接到单位的整个大局域网，那么也可以说单位的大局域网是外网，办公室内的小局域网是内网。同时，如果单位的大局域网连接了Internet，那么相对于Internet，也可以说单位的大局域网是内网。
内网可能是一个独立的局域网，通过其中的网关（网关就是连接两个网络的节点，说白了，就是有双重身份的电脑，既有局域网的IP地址，又有Internet的IP地址，两个IP地址分别捆绑在不同的网卡上）的代理访问外部网络，比如网吧都是这样实现的，其特征是：网吧内的电脑的ip都是局域网专用ip，比如192.168.xxx.xxx或者10.xxx.xxx.xxx，而这种ip在internet上面是不会出现的。
（注：所谓代理，就是你提要求，他来办事，类似于代购火车票。局域网的电脑想和外面联络，就把对方地址告诉服务器，也就是网关，网关以自己的身份和对方联络，同时把对方发回来的消息转送给局域网内的电脑。因此，对方看不见局域网内电脑的IP，只会以为是网关那台电脑在与自己交流。例如：网吧内的所有QQ都显示同样的IP

内网也可能是外网的一个部分，比如校园网，或者相对于单位局域网的办公室内部局域网。其特征是：内网电脑的ip就是整个外网ip范围的一部分，内网的电脑通过网关（路由器）连接到外网，网关不需要进行代理服务，直接路由就行了。！！！！

注：所谓路由，就是路径选择。路由器连接多个网络，因此一定是各个网络的网关，其作用类似于邮局。你想联系局域网外的电脑，就把邮包发送给路由器，路由器会帮你投递到邮包上标明的地址。这样，收到邮包的人可以知道是谁把邮包发过来的，但是，他无法知道发邮包的人是不是帮别人代理发邮包的。或者说，收到数据的电脑可以知道是哪台电脑在与它联络，但它无法知道与它联络的这台电脑是否是某个局域网的代理服务器。

广域网上的每一台电脑（或其他网络设备）都有一个或多个广域网IP地址（或者说公网、外网IP地址），广域网IP地址一般要到ISP处交费之后才能申请到，广域网IP地址不能重复！！！！！；局域网（LAN）上的每一台电脑（或其他网络设备）都有一个或多个局域网IP地址（或者说私网、内网IP地址），局域网IP地址是局域网内部分配的，不同局域网的IP地址可以重复！！！！！！，不会相互影响。

通常情况下，网关或路由器对内部向外发出的信息不会进行拦截，但对来自外部想进入内部网络的信息则会进行识别、筛选，认为是安全的、有效的，才会转发给内网电脑。


万维网（www）只是互联网提供的服务之一
Internet是最基本的协议是TCP/IP

从下往上：
应用层：Telnet、FTP和E-mail等	http位于应用层
传输层：TCP和UDP
网络层：IP、ICMP和IGMP
链路层：设备驱动程序及接口卡

正向代理和反向代理：http://blog.csdn.net/m13666368773/article/details/8060481
正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

反向代理：对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理 的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。


重载和重写，这是两个新概念，是两个令我们容易混淆的概念：
1.重载(overloading method)
是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。重载是让类以统一的方式处理不同类型数据的一种手段。
函数重载主要是为了解决两个问题。
	1.可变参数类型。
	2.可变参数个数。

2.方法重写(overiding method) 
子类不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖
















链接：https://www.zhihu.com/question/30557267/answer/48623150
数据挖掘：也就是data mining，是一个很宽泛的概念。字面意思就是从成吨的数据里面挖掘有用的信息。这个工作BI（商业智能）可以做，数据分析可以做，甚至市场运营也可以做。你用excel分析分析数据，发现了一些有用的信息，然后这些信息可以指导你的business，恭喜你，你已经会数据挖掘了。
机器学习：machine learning，是计算机科学和统计学的交叉学科，基本目标是学习一个x->y的函数（映射），来做分类或者回归的工作。之所以经常和数据挖掘合在一起讲是因为现在好多数据挖掘的工作是通过机器学习提供的算法工具实现的，例如广告的ctr预估，PB级别的点击日志在通过典型的机器学习流程可以得到一个预估模型，从而提高互联网广告的点击率和回报率；个性化推荐，还是通过机器学习的一些算法分析平台上的各种购买，浏览和收藏日志，得到一个推荐模型，来预测你喜欢的商品。
深度学习：deep learning，机器学习里面现在比较火的一个topic（大坑），本身是神经网络算法的衍生，在图像，语音等富媒体的分类和识别上取得了非常好的效果，所以各大研究机构和公司都投入了大量的人力做相关的研究和开发。总结下，数据挖掘是个很宽泛的概念，数据挖掘常用方法大多来自于机器学习这门学科，深度学习是机器学习一类比较火的算法，本质上还是原来的神经网络。
